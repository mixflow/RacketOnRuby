
class Racket
    def tokenize(str)
       str.gsub("(", "( ") # add space after '('
           .gsub!(")", " )") # add space before ')'
           .split(" ") # split string into an array(tokens) base on whitespaces
    end

    def generate_ast(tokens)
        def aux(tokens, acc)
            # the auxiliary(helper) function
            # @param tokens: the token array which is generated by 'tokenize' function
            # @param acc: the accumulator holds the result. array(maybe nested), default []

            if tokens.empty?
                # no tokens left, return result
                return acc
            end

            token = tokens.shift # get first token
            if '(' == token # start one s-expression
                sub_ast = aux tokens, []
                acc.push sub_ast

                aux(tokens,  acc) # recursive call to continue handling rest tokens
            elsif ')' == token # end one s-expression
                return acc
            else
                acc.push atom(token) # convent current token to atom
                aux tokens, acc # recursive
            end
        end

        aux tokens, [] # initial call helper
    end

    def atom(token)
        # TODO
        token
    end
end
