
class Racket
    def tokenize(str)
       str.gsub("(", "( ") # add space after '('
          .gsub(")", " )") # add space before ')'
          .gsub("[", "[ ")
          .gsub("]", " ]")
          .split(" ") # split string into an array(tokens) base on whitespaces
    end

    def generate_ast(tokens)
        parenthesis_map = {"("=>")", "["=>"]"} # the march parenthesis
        aux = lambda do |tokens, acc, left_parenthesis=nil|
            # the auxiliary(helper) function
            # @param tokens: the token array which is generated by 'tokenize' function
            # @param acc: the accumulator holds the result. array(maybe nested), default []

            if tokens.empty?
                # no tokens left, return result
                return acc
            end

            token = tokens.shift # get first token
            if '(' == token or '[' == token # start one s-expression
                sub_ast = aux.call tokens, [], token
                acc.push sub_ast

                aux.call(tokens,  acc, left_parenthesis) # recursive call to continue handling rest tokens
            elsif ')' == token or ']' == token # end one s-expression
                # match parenthesis
                if left_parenthesis.nil?
                    raise "unexpected \"%s\" ." % token
                elsif parenthesis_map[left_parenthesis] != token
                    raise "unmatched parenthesis. excepted \"%s\" to close \"%s\", found instead \"%s\"." % [
                        parenthesis_map[left_parenthesis], left_parenthesis, token]
                else
                    return acc
                end
            else
                acc.push atom(token) # convent current token to atom
                aux.call tokens, acc, left_parenthesis # recursive
            end
        end
        # initial call helper. copy tokens pass to 'aux', because tokens will be mutated in 'aux'
        aux.call tokens[0..-1], [], nil
    end

    def atom(token)
        str_part = token[/^"(.*)"$/, 1] # try match string(start and end with ")
        if not str_part.nil?
            str_part
        elsif token[/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/]  # decimal
            token.to_f
        elsif token[/^\d+$/] # integer
            token.to_i
        else # symbol
            token.to_sym
        end
    end

    def parse(str)
        generate_ast( tokenize(str) )
    end

    def initialize()
        @env = {
            :+ => lambda{|x, y| x+y},
            :* => lambda{|x, y| x*y}
        }
    end

    def eval_expressions(exps, env=@env)
        results = exps.map { |one_exp| eval(one_exp, env) }
        results[-1]
    end

    def eval(exp, env=@env)
        def lookup_env(env, var)
            error_no_var = "undefined: \"%s\"" % var
            val = env[var]

            if val.nil?
                raise error_no_var
            else
                return val
            end
        end

        if exp.is_a? Numeric
            exp # is a number(integer and float) return itself
        elsif exp.is_a? Symbol
            lookup_env(env, exp)
        else
            operator = eval(exp[0], env) # first thing of s-expression sequence.
            operands = exp[1..-1].map {|sub_exp| eval(sub_exp, env) } # the rest things of sequence
            operator.call *operands
        end
    end
end
