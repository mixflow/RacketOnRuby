
class Racket
    def tokenize(str)
       str.gsub("(", "( ") # add space after '('
          .gsub(")", " )") # add space before ')'
          .gsub("[", "[ ")
          .gsub("]", " ]")
          .split(" ") # split string into an array(tokens) base on whitespaces
    end

    def generate_ast(tokens)
        parenthesis_map = {"("=>")", "["=>"]"} # the march parenthesis
        aux = lambda do |tokens, acc, left_parenthesis=nil|
            # the auxiliary(helper) function
            # @param tokens: the token array which is generated by 'tokenize' function
            # @param acc: the accumulator holds the result. array(maybe nested), default []

            if tokens.empty?
                # no tokens left, return result
                return acc
            end

            token = tokens.shift # get first token
            if '(' == token or '[' == token # start one s-expression
                sub_ast = aux.call tokens, [], token
                acc.push sub_ast

                aux.call(tokens,  acc, left_parenthesis) # recursive call to continue handling rest tokens
            elsif ')' == token or ']' == token # end one s-expression
                # match parenthesis
                if left_parenthesis.nil?
                    raise "unexpected \"%s\" ." % token
                elsif parenthesis_map[left_parenthesis] != token
                    raise "unmatched parenthesis. excepted \"%s\" to close \"%s\", found instead \"%s\"." % [
                        parenthesis_map[left_parenthesis], left_parenthesis, token]
                else
                    return acc
                end
            else
                acc.push atom(token) # convent current token to atom
                aux.call tokens, acc, left_parenthesis # recursive
            end
        end

        aux.call tokens, [], nil # initial call helper
    end

    def atom(token)
        str_part = token[/^(.*)$/, 1] # try match string(start and end with ")
        if not str_part.nil?
            str_part
        elsif token[/(?=(\.|[eE]))(\.\d+)?([eE][+-]?\d+)?$/]  # decimal
            token.to_f
        elsif token[/^\d+$/] # integer
            token.to_i
        else # symbol
            token.to_sym
        end
    end
end
